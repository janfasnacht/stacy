/// Integration tests for nested do-files
///
/// Tests that the parser correctly handles Stata logs with multiple
/// "end of do-file" markers (from nested do-file calls).
use stacy::error::parser::{parse_log_content, parse_log_file};
use std::path::PathBuf;

#[test]
#[ignore] // Requires log files generated by Stata - run locally after generating logs
fn test_nested_success() {
    // Nested do-file that succeeds
    let log_path = PathBuf::from("tests/log-analysis/13_nested_success.log");
    let errors = parse_log_file(&log_path).expect("Failed to parse log");

    assert_eq!(errors.len(), 0, "Nested success should have no errors");
}

#[test]
#[ignore] // Requires log files generated by Stata - run locally after generating logs
fn test_nested_error() {
    // Nested do-file with error in helper
    // Log contains TWO "end of do-file" markers:
    // 1. From nested/helper_with_error.do
    // 2. From main script 14_nested_error.do
    //
    // Parser should use the LAST marker (from main script)
    let log_path = PathBuf::from("tests/log-analysis/14_nested_error.log");
    let errors = parse_log_file(&log_path).expect("Failed to parse log");

    assert_eq!(errors.len(), 1, "Should detect exactly one error");

    assert_eq!(
        errors[0].r_code(),
        Some(111),
        "Should detect r(111) - variable not found"
    );
}

#[test]
fn test_nested_multiple_end_markers() {
    // Verify the parser uses rposition() to find the LAST "end of do-file"
    // This is critical for nested do-files
    let log_content = r#"
=== Inside helper_with_error.do ===
bad_var not found
r(111);

end of do-file
r(111);

end of do-file
r(111);
"#;

    let errors = parse_log_content(log_content).expect("Failed to parse log content");

    assert_eq!(
        errors.len(),
        1,
        "Should find error after LAST 'end of do-file' marker"
    );

    assert_eq!(errors[0].r_code(), Some(111));
}
