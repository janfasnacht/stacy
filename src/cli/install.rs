//! `stacy install` command implementation
//!
//! Installs all packages from the lockfile. Use `stacy add` to add new packages.

use crate::cli::output_format::OutputFormat;
use crate::cli::output_types::{CommandOutput, InstallOutput};
use crate::error::{Error, Result};
use crate::packages::global_cache;
use crate::packages::installer::{install_package, install_package_github, is_package_installed};
use crate::packages::lockfile::{check_version_mismatch, load_lockfile, verify_lockfile_sync};
use crate::packages::ssc::{calculate_combined_checksum, calculate_sha256};
use crate::project::config::load_config;
use crate::project::{PackageSource, Project};
use clap::Args;
use std::collections::HashSet;
use std::path::Path;

#[derive(Args)]
#[command(after_help = "\
Examples:
  stacy install                           Install all packages from lockfile
  stacy install --with dev                Include dev dependencies
  stacy install --no-verify               Skip checksum verification
  stacy install --frozen                  Fail if lockfile is out of sync (for CI)")]
pub struct InstallArgs {
    /// Skip checksum verification
    #[arg(long)]
    pub no_verify: bool,

    /// Include additional dependency groups (comma-separated: dev, test)
    #[arg(long, value_delimiter = ',')]
    pub with: Vec<String>,

    /// Fail if lockfile doesn't match stacy.toml (for CI reproducibility)
    #[arg(long)]
    pub frozen: bool,

    /// Output format: human (default), json, or stata
    #[arg(long, value_enum, default_value = "human")]
    pub format: OutputFormat,
}

pub fn execute(args: &InstallArgs) -> Result<()> {
    install_from_lockfile(args)
}

/// Install all packages from lockfile (replaces sync command)
fn install_from_lockfile(args: &InstallArgs) -> Result<()> {
    let format = args.format;

    // Find project
    let project = Project::find()?.ok_or_else(|| {
        Error::Config("Not in a stacy project. Run 'stacy init' first.".to_string())
    })?;

    // Load lockfile
    let lockfile = load_lockfile(&project.root)?.ok_or_else(|| {
        Error::Config("No stacy.lock found. Use 'stacy add <package>' to add packages.".to_string())
    })?;

    // Check for stacy version mismatch
    if args.format == OutputFormat::Human {
        if let Some((lockfile_ver, current_ver)) = check_version_mismatch(&lockfile) {
            use colored::Colorize;
            eprintln!(
                "{} stacy.lock was generated by stacy v{}, but you are running v{}",
                "warning:".yellow().bold(),
                lockfile_ver,
                current_ver
            );
            eprintln!("         Run `stacy lock` to update the lockfile\n");
        }
    }

    // If --frozen, verify lockfile is in sync with manifest
    if args.frozen {
        let config = load_config(&project.root)?
            .ok_or_else(|| Error::Config("No stacy.toml found.".to_string()))?;

        let config_package_names: Vec<&str> = config
            .packages
            .all_packages()
            .map(|(name, _, _)| name.as_str())
            .collect();

        let sync_result = verify_lockfile_sync(&lockfile, &config_package_names);

        if !sync_result.in_sync {
            let mut msg = String::from("Lockfile out of sync with stacy.toml (--frozen mode)\n");

            if !sync_result.missing_in_lock.is_empty() {
                msg.push_str("\n  Missing from stacy.lock:\n");
                for name in &sync_result.missing_in_lock {
                    msg.push_str(&format!("    - {}\n", name));
                }
            }

            if !sync_result.extra_in_lock.is_empty() {
                msg.push_str("\n  Extra in stacy.lock (not in stacy.toml):\n");
                for name in &sync_result.extra_in_lock {
                    msg.push_str(&format!("    - {}\n", name));
                }
            }

            msg.push_str("\n  hint: run `stacy lock` then commit stacy.lock");

            return Err(Error::Config(msg));
        }
    }

    // Determine which groups to install
    let mut groups_to_install: HashSet<&str> = HashSet::new();
    groups_to_install.insert("production"); // Always include production

    for group_name in &args.with {
        match group_name.to_lowercase().as_str() {
            "dev" => {
                groups_to_install.insert("dev");
            }
            "test" => {
                groups_to_install.insert("test");
            }
            other => {
                return Err(Error::Config(format!(
                    "Unknown dependency group: '{}'. Valid groups: dev, test",
                    other
                )));
            }
        }
    }

    // Filter packages based on their group in the lockfile
    let packages_to_install: Vec<_> = lockfile
        .packages
        .iter()
        .filter(|(_, entry)| groups_to_install.contains(entry.group.as_str()))
        .collect();

    if packages_to_install.is_empty() {
        let output = InstallOutput {
            status: "success".to_string(),
            installed: 0,
            already_installed: 0,
            skipped: 0,
            total: 0,
            package_count: 0,
        };

        match format {
            OutputFormat::Json => {
                println!(
                    r#"{{"status": "success", "message": "No packages to install", "packages": []}}"#
                );
            }
            OutputFormat::Stata => println!("{}", output.to_stata()),
            OutputFormat::Human => {
                if args.with.is_empty() {
                    println!("No production packages in stacy.lock.");
                } else {
                    let groups: Vec<_> = groups_to_install.iter().copied().collect();
                    println!("No packages to install for groups: {}", groups.join(", "));
                }
            }
        }
        return Ok(());
    }

    if format == OutputFormat::Human {
        let groups: Vec<_> = groups_to_install.iter().copied().collect();
        println!("Installing packages ({})...", groups.join(", "));
        println!();
    }

    let mut results: Vec<SyncedPackage> = Vec::new();

    // Process each package
    let verify = !args.no_verify;
    for (name, entry) in packages_to_install {
        let result = sync_package(name, entry, &project.root, verify)?;
        results.push(result);
    }

    // Build output struct
    let installed_count = results
        .iter()
        .filter(|r| matches!(r.action, SyncAction::Installed))
        .count() as i32;
    let already_count = results
        .iter()
        .filter(|r| matches!(r.action, SyncAction::AlreadyInstalled))
        .count() as i32;
    let skipped_count = results
        .iter()
        .filter(|r| matches!(r.action, SyncAction::Skipped(_)))
        .count() as i32;

    let output = InstallOutput {
        status: if skipped_count > 0 && installed_count == 0 {
            "error".to_string()
        } else {
            "success".to_string()
        },
        installed: installed_count,
        already_installed: already_count,
        skipped: skipped_count,
        total: results.len() as i32,
        package_count: results.len(),
    };

    // Output results
    match format {
        OutputFormat::Json => print_sync_json_output(&results),
        OutputFormat::Stata => println!("{}", output.to_stata()),
        OutputFormat::Human => print_sync_human_output(&results),
    }

    // Checksum failure is a hard error
    if verify {
        let fail_count = results
            .iter()
            .filter(|r| r.checksum_ok == Some(false))
            .count();
        if fail_count > 0 {
            return Err(Error::Config(format!(
                "{} package(s) failed checksum verification. Use --no-verify to skip.",
                fail_count
            )));
        }
    }

    Ok(())
}

// ============================================================================
// Sync functionality (install from lockfile)
// ============================================================================

/// Result of syncing a package
#[derive(Debug)]
struct SyncedPackage {
    name: String,
    version: String,
    action: SyncAction,
    checksum_ok: Option<bool>,
}

#[derive(Debug)]
enum SyncAction {
    Installed,
    AlreadyInstalled,
    Skipped(String),
}

fn sync_package(
    name: &str,
    entry: &crate::project::PackageEntry,
    project_root: &Path,
    verify: bool,
) -> Result<SyncedPackage> {
    // Check if already installed in global cache
    if is_package_installed(name, &entry.version) {
        // Verify checksum if requested
        let checksum_ok = if verify {
            verify_package_checksum(name, entry)
        } else {
            None
        };

        return Ok(SyncedPackage {
            name: name.to_string(),
            version: entry.version.clone(),
            action: SyncAction::AlreadyInstalled,
            checksum_ok,
        });
    }

    // Install based on source
    let group = entry.group.as_str();
    match &entry.source {
        PackageSource::SSC { name: pkg_name } => {
            match install_package(pkg_name, "ssc", project_root, group) {
                Ok(result) => {
                    // Warn if downloaded from mirror and checksum differs from lockfile
                    if result.from_mirror {
                        if let Some(expected) = &entry.checksum {
                            let expected = expected.strip_prefix("sha256:").unwrap_or(expected);
                            if result.package_checksum != expected {
                                use colored::Colorize;
                                eprintln!(
                                    "{} {} downloaded from mirror; checksum differs from lockfile",
                                    "warning:".yellow().bold(),
                                    name,
                                );
                                eprintln!(
                                    "    hint: SSC primary may have updated. Run `stacy update {}` to refresh.",
                                    name,
                                );
                            }
                        }
                    }

                    let checksum_ok = if verify {
                        verify_package_checksum(name, entry)
                    } else {
                        None
                    };

                    Ok(SyncedPackage {
                        name: name.to_string(),
                        version: entry.version.clone(),
                        action: SyncAction::Installed,
                        checksum_ok,
                    })
                }
                Err(e) => Ok(SyncedPackage {
                    name: name.to_string(),
                    version: entry.version.clone(),
                    action: SyncAction::Skipped(e.to_string()),
                    checksum_ok: None,
                }),
            }
        }
        PackageSource::GitHub { repo, tag, commit } => {
            // Parse repo into user/repo
            let parts: Vec<&str> = repo.split('/').collect();
            if parts.len() == 2 {
                // Use commit SHA for downloads when available (exact reproducibility)
                let git_ref = commit.as_deref().unwrap_or(tag.as_str());
                match install_package_github(
                    name,
                    parts[0],
                    parts[1],
                    Some(git_ref),
                    project_root,
                    group,
                ) {
                    Ok(_) => {
                        let checksum_ok = if verify {
                            verify_package_checksum(name, entry)
                        } else {
                            None
                        };

                        Ok(SyncedPackage {
                            name: name.to_string(),
                            version: entry.version.clone(),
                            action: SyncAction::Installed,
                            checksum_ok,
                        })
                    }
                    Err(e) => Ok(SyncedPackage {
                        name: name.to_string(),
                        version: entry.version.clone(),
                        action: SyncAction::Skipped(e.to_string()),
                        checksum_ok: None,
                    }),
                }
            } else {
                Ok(SyncedPackage {
                    name: name.to_string(),
                    version: entry.version.clone(),
                    action: SyncAction::Skipped(format!("Invalid repo format: {}", repo)),
                    checksum_ok: None,
                })
            }
        }
        PackageSource::Local { path } => {
            match crate::packages::installer::install_from_local(name, path, project_root, group) {
                Ok(_) => {
                    let checksum_ok = if verify {
                        verify_package_checksum(name, entry)
                    } else {
                        None
                    };
                    Ok(SyncedPackage {
                        name: name.to_string(),
                        version: entry.version.clone(),
                        action: SyncAction::Installed,
                        checksum_ok,
                    })
                }
                Err(e) => Ok(SyncedPackage {
                    name: name.to_string(),
                    version: entry.version.clone(),
                    action: SyncAction::Skipped(e.to_string()),
                    checksum_ok: None,
                }),
            }
        }
        PackageSource::Net { url } => {
            match crate::packages::installer::install_from_net(name, url, project_root, group) {
                Ok(result) => {
                    let checksum_ok = if verify {
                        verify_package_checksum(name, entry)
                    } else {
                        None
                    };
                    Ok(SyncedPackage {
                        name: name.to_string(),
                        version: result.version,
                        action: SyncAction::Installed,
                        checksum_ok,
                    })
                }
                Err(e) => Ok(SyncedPackage {
                    name: name.to_string(),
                    version: entry.version.clone(),
                    action: SyncAction::Skipped(e.to_string()),
                    checksum_ok: None,
                }),
            }
        }
    }
}

fn verify_package_checksum(name: &str, entry: &crate::project::PackageEntry) -> Option<bool> {
    // Get expected checksum from lockfile
    let expected = entry.checksum.as_ref()?;
    let expected = expected.strip_prefix("sha256:").unwrap_or(expected);

    // Find the package in the global cache
    let cache_dir = global_cache::package_path(name, &entry.version).ok()?;
    if !cache_dir.exists() {
        return Some(false);
    }

    // Collect SHA256 of every file in cache dir
    let mut checksums = Vec::new();
    let entries = std::fs::read_dir(&cache_dir).ok()?;
    for dir_entry in entries {
        let dir_entry = dir_entry.ok()?;
        if dir_entry.path().is_file() {
            let content = std::fs::read(dir_entry.path()).ok()?;
            checksums.push(calculate_sha256(&content));
        }
    }

    if checksums.is_empty() {
        return Some(false);
    }

    // calculate_combined_checksum sorts internally (H2 fix)
    let actual = calculate_combined_checksum(&checksums);
    Some(actual == expected)
}

fn print_sync_json_output(results: &[SyncedPackage]) {
    use serde_json::json;

    let packages: Vec<_> = results
        .iter()
        .map(|r| {
            json!({
                "name": r.name,
                "version": r.version,
                "action": match &r.action {
                    SyncAction::Installed => "installed",
                    SyncAction::AlreadyInstalled => "already_installed",
                    SyncAction::Skipped(_) => "skipped",
                },
                "error": match &r.action {
                    SyncAction::Skipped(e) => Some(e.as_str()),
                    _ => None,
                },
                "checksum_verified": r.checksum_ok,
            })
        })
        .collect();

    let installed_count = results
        .iter()
        .filter(|r| matches!(r.action, SyncAction::Installed))
        .count();
    let already_count = results
        .iter()
        .filter(|r| matches!(r.action, SyncAction::AlreadyInstalled))
        .count();
    let skipped_count = results
        .iter()
        .filter(|r| matches!(r.action, SyncAction::Skipped(_)))
        .count();

    let output = json!({
        "status": "success",
        "packages": packages,
        "summary": {
            "installed": installed_count,
            "already_installed": already_count,
            "skipped": skipped_count,
            "total": results.len(),
        }
    });

    println!("{}", serde_json::to_string_pretty(&output).unwrap());
}

fn print_sync_human_output(results: &[SyncedPackage]) {
    let mut installed = Vec::new();
    let mut already = Vec::new();
    let mut skipped = Vec::new();

    for result in results {
        match &result.action {
            SyncAction::Installed => {
                println!("  Installing {} ({})...", result.name, result.version);
                installed.push(&result.name);
            }
            SyncAction::AlreadyInstalled => {
                already.push(&result.name);
            }
            SyncAction::Skipped(reason) => {
                println!(
                    "  Skipping {} ({}): {}",
                    result.name, result.version, reason
                );
                skipped.push(&result.name);
            }
        }
    }

    println!();

    // Summary
    if installed.is_empty() && skipped.is_empty() {
        println!("All {} packages already installed.", already.len());
    } else {
        let mut summary = Vec::new();
        if !installed.is_empty() {
            summary.push(format!("{} installed", installed.len()));
        }
        if !already.is_empty() {
            summary.push(format!("{} already installed", already.len()));
        }
        if !skipped.is_empty() {
            summary.push(format!("{} skipped", skipped.len()));
        }
        println!("Install complete: {}", summary.join(", "));
    }

    // Checksum verification results
    let verified: Vec<_> = results.iter().filter(|r| r.checksum_ok.is_some()).collect();
    if !verified.is_empty() {
        println!();
        let ok_count = verified
            .iter()
            .filter(|r| r.checksum_ok == Some(true))
            .count();
        let fail_count = verified
            .iter()
            .filter(|r| r.checksum_ok == Some(false))
            .count();

        if fail_count > 0 {
            let failed_names: Vec<_> = verified
                .iter()
                .filter(|r| r.checksum_ok == Some(false))
                .map(|r| r.name.as_str())
                .collect();
            eprintln!(
                "Error: {} package(s) failed checksum verification: {}",
                fail_count,
                failed_names.join(", ")
            );
        } else {
            println!("Checksums verified: {}/{}", ok_count, verified.len());
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serial_test::serial;
    use tempfile::TempDir;

    // Helper to set up a test cache directory
    fn with_test_cache<F, R>(f: F) -> R
    where
        F: FnOnce(&TempDir) -> R,
    {
        let temp = TempDir::new().unwrap();
        std::env::set_var("XDG_CACHE_HOME", temp.path());
        let result = f(&temp);
        std::env::remove_var("XDG_CACHE_HOME");
        result
    }

    // C1: Test that verify_package_checksum matches combined checksum
    #[test]
    #[serial]
    fn test_verify_checksum_matches_combined() {
        with_test_cache(|_temp| {
            use crate::packages::ssc::calculate_sha256;
            use crate::project::{PackageEntry, PackageSource};

            let cache_dir = global_cache::ensure_package_cache_dir("verifypkg", "1.0.0").unwrap();

            // Write known files
            let content1 = b"file one content";
            let content2 = b"file two content";
            std::fs::write(cache_dir.join("verifypkg.ado"), content1).unwrap();
            std::fs::write(cache_dir.join("verifypkg.sthlp"), content2).unwrap();

            // Compute the expected combined checksum (same algorithm as production code)
            let checksums = vec![calculate_sha256(content1), calculate_sha256(content2)];
            let expected = calculate_combined_checksum(&checksums);

            let entry = PackageEntry {
                version: "1.0.0".to_string(),
                source: PackageSource::SSC {
                    name: "verifypkg".to_string(),
                },
                checksum: Some(format!("sha256:{}", expected)),
                group: "production".to_string(),
            };

            let result = verify_package_checksum("verifypkg", &entry);
            assert_eq!(result, Some(true));
        });
    }

    // C1: Test that tampered file fails verification
    #[test]
    #[serial]
    fn test_verify_checksum_fails_on_tamper() {
        with_test_cache(|_temp| {
            use crate::packages::ssc::calculate_sha256;
            use crate::project::{PackageEntry, PackageSource};

            let cache_dir = global_cache::ensure_package_cache_dir("tamperpkg", "1.0.0").unwrap();

            // Write files and compute checksum
            let content1 = b"original content";
            let content2 = b"helper content";
            std::fs::write(cache_dir.join("tamperpkg.ado"), content1).unwrap();
            std::fs::write(cache_dir.join("tamperpkg.sthlp"), content2).unwrap();

            let checksums = vec![calculate_sha256(content1), calculate_sha256(content2)];
            let expected = calculate_combined_checksum(&checksums);

            let entry = PackageEntry {
                version: "1.0.0".to_string(),
                source: PackageSource::SSC {
                    name: "tamperpkg".to_string(),
                },
                checksum: Some(format!("sha256:{}", expected)),
                group: "production".to_string(),
            };

            // Tamper with a file
            std::fs::write(cache_dir.join("tamperpkg.ado"), b"TAMPERED").unwrap();

            let result = verify_package_checksum("tamperpkg", &entry);
            assert_eq!(result, Some(false));
        });
    }

    // C1: Test cache-hit path â€” package already cached with verify=true returns checksum_ok
    #[test]
    #[serial]
    fn test_cache_hit_verification_path() {
        with_test_cache(|_temp| {
            use crate::packages::ssc::calculate_sha256;
            use crate::project::{PackageEntry, PackageSource};

            let cache_dir = global_cache::ensure_package_cache_dir("hitpkg", "1.0.0").unwrap();

            // Write known files
            let content1 = b"hitpkg ado content";
            let content2 = b"hitpkg help content";
            std::fs::write(cache_dir.join("hitpkg.ado"), content1).unwrap();
            std::fs::write(cache_dir.join("hitpkg.sthlp"), content2).unwrap();

            // Compute correct checksum
            let checksums = vec![calculate_sha256(content1), calculate_sha256(content2)];
            let expected = calculate_combined_checksum(&checksums);

            let entry = PackageEntry {
                version: "1.0.0".to_string(),
                source: PackageSource::SSC {
                    name: "hitpkg".to_string(),
                },
                checksum: Some(format!("sha256:{}", expected)),
                group: "production".to_string(),
            };

            // Package is already installed (cache hit)
            assert!(
                is_package_installed("hitpkg", "1.0.0"),
                "Package should be in cache"
            );

            // verify_package_checksum should return Some(true) for valid cache
            let result = verify_package_checksum("hitpkg", &entry);
            assert_eq!(
                result,
                Some(true),
                "Cache-hit with valid checksum must return Some(true)"
            );
        });
    }

    // C1: Test verification with no checksum in lockfile returns None
    #[test]
    #[serial]
    fn test_verify_checksum_none_when_no_checksum() {
        with_test_cache(|_temp| {
            use crate::project::{PackageEntry, PackageSource};

            let entry = PackageEntry {
                version: "1.0.0".to_string(),
                source: PackageSource::SSC {
                    name: "nochecksum".to_string(),
                },
                checksum: None,
                group: "production".to_string(),
            };

            let result = verify_package_checksum("nochecksum", &entry);
            assert_eq!(result, None);
        });
    }
}
