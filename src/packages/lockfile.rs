//! Lockfile management for stacy.lock
//!
//! The lockfile records installed packages with their versions, sources,
//! and checksums for reproducible environments.

use crate::error::{Error, Result};
use crate::project::{Lockfile, PackageEntry, PackageSource};
use std::collections::HashMap;
use std::path::Path;

/// Header comment for stacy.lock
const LOCKFILE_HEADER: &str = r#"# Auto-generated by stacy - do not edit manually
# Use `stacy install` to manage packages
"#;

/// Load lockfile from project root
///
/// Returns None if lockfile doesn't exist
pub fn load_lockfile(project_root: &Path) -> Result<Option<Lockfile>> {
    let lockfile_path = project_root.join("stacy.lock");

    if !lockfile_path.exists() {
        return Ok(None);
    }

    let content = std::fs::read_to_string(&lockfile_path).map_err(|e| {
        Error::Io(std::io::Error::new(
            e.kind(),
            format!("Failed to read stacy.lock: {}", e),
        ))
    })?;

    let lockfile: Lockfile = toml::from_str(&content)
        .map_err(|e| Error::Config(format!("Invalid stacy.lock format: {}", e)))?;

    Ok(Some(lockfile))
}

/// Save lockfile to project root
pub fn save_lockfile(project_root: &Path, lockfile: &Lockfile) -> Result<()> {
    let lockfile_path = project_root.join("stacy.lock");

    // Always update stacy_version to current version when saving
    let mut lockfile_to_save = lockfile.clone();
    lockfile_to_save.stacy_version = Some(env!("CARGO_PKG_VERSION").to_string());

    // Serialize to TOML Value, then sort the packages table alphabetically
    // for deterministic lockfile output (M1).
    let mut value = toml::Value::try_from(&lockfile_to_save)
        .map_err(|e| Error::Config(format!("Failed to serialize lockfile: {}", e)))?;

    if let Some(packages_table) = value.get("packages").and_then(|v| v.as_table()) {
        let mut sorted = toml::map::Map::new();
        let mut keys: Vec<_> = packages_table.keys().collect();
        keys.sort();
        for key in keys {
            sorted.insert(key.clone(), packages_table[key].clone());
        }
        value["packages"] = toml::Value::Table(sorted);
    }

    let content = toml::to_string_pretty(&value)
        .map_err(|e| Error::Config(format!("Failed to serialize lockfile: {}", e)))?;

    // Add header and write
    let full_content = format!("{}\n{}", LOCKFILE_HEADER, content);

    std::fs::write(&lockfile_path, full_content).map_err(|e| {
        Error::Io(std::io::Error::new(
            e.kind(),
            format!("Failed to write stacy.lock: {}", e),
        ))
    })?;

    Ok(())
}

/// Create a new empty lockfile
pub fn create_lockfile() -> Lockfile {
    Lockfile {
        version: "1".to_string(),
        stacy_version: Some(env!("CARGO_PKG_VERSION").to_string()),
        packages: HashMap::new(),
    }
}

/// Check if lockfile was generated by a different stacy version.
/// Returns Some((lockfile_version, current_version)) if mismatch.
pub fn check_version_mismatch(lockfile: &Lockfile) -> Option<(String, String)> {
    let current_version = env!("CARGO_PKG_VERSION");
    match &lockfile.stacy_version {
        Some(lockfile_ver) if lockfile_ver != current_version => {
            Some((lockfile_ver.clone(), current_version.to_string()))
        }
        _ => None,
    }
}

/// Add or update a package in the lockfile
pub fn add_package(lockfile: &mut Lockfile, name: &str, entry: PackageEntry) {
    lockfile.packages.insert(name.to_string(), entry);
}

/// Remove a package from the lockfile
pub fn remove_package(lockfile: &mut Lockfile, name: &str) -> Option<PackageEntry> {
    lockfile.packages.remove(name)
}

/// Check if a package is in the lockfile
pub fn has_package(lockfile: &Lockfile, name: &str) -> bool {
    lockfile.packages.contains_key(name)
}

/// Result of verifying lockfile sync with manifest
#[derive(Debug)]
pub struct LockfileSyncResult {
    /// Whether lockfile is in sync with manifest
    pub in_sync: bool,
    /// Packages in manifest but not in lockfile
    pub missing_in_lock: Vec<String>,
    /// Packages in lockfile but not in manifest
    pub extra_in_lock: Vec<String>,
}

/// Verify that lockfile is in sync with the manifest (stacy.toml).
///
/// This is used by `--frozen` mode to ensure reproducible builds in CI.
/// Returns details about any differences found.
pub fn verify_lockfile_sync(
    lockfile: &Lockfile,
    config_package_names: &[&str],
) -> LockfileSyncResult {
    let mut missing_in_lock = Vec::new();
    let mut extra_in_lock = Vec::new();

    // Check for packages in config but not in lockfile
    for name in config_package_names {
        if !lockfile.packages.contains_key(*name) {
            missing_in_lock.push(name.to_string());
        }
    }

    // Check for packages in lockfile but not in config
    let config_names: std::collections::HashSet<&str> =
        config_package_names.iter().copied().collect();
    for name in lockfile.packages.keys() {
        if !config_names.contains(name.as_str()) {
            extra_in_lock.push(name.clone());
        }
    }

    let in_sync = missing_in_lock.is_empty() && extra_in_lock.is_empty();

    LockfileSyncResult {
        in_sync,
        missing_in_lock,
        extra_in_lock,
    }
}

/// Get a package entry from the lockfile
pub fn get_package<'a>(lockfile: &'a Lockfile, name: &str) -> Option<&'a PackageEntry> {
    lockfile.packages.get(name)
}

/// Create a package entry from download information
pub fn create_package_entry(
    version: &str,
    source: PackageSource,
    checksum: &str,
    group: &str,
) -> PackageEntry {
    PackageEntry {
        version: version.to_string(),
        source,
        checksum: if checksum.is_empty() {
            None
        } else {
            Some(format!("sha256:{}", checksum))
        },
        group: group.to_string(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_create_lockfile() {
        let lockfile = create_lockfile();
        assert_eq!(lockfile.version, "1");
        assert!(lockfile.packages.is_empty());
    }

    #[test]
    fn test_create_lockfile_includes_stacy_version() {
        let lockfile = create_lockfile();
        assert!(lockfile.stacy_version.is_some());
        assert_eq!(lockfile.stacy_version.unwrap(), env!("CARGO_PKG_VERSION"));
    }

    #[test]
    fn test_add_package() {
        let mut lockfile = create_lockfile();

        let entry = PackageEntry {
            version: "1.0.0".to_string(),
            source: PackageSource::SSC {
                name: "testpkg".to_string(),
            },
            checksum: Some("sha256:abc123".to_string()),
            group: "production".to_string(),
        };

        add_package(&mut lockfile, "testpkg", entry);

        assert!(has_package(&lockfile, "testpkg"));
        assert!(!has_package(&lockfile, "other"));
    }

    #[test]
    fn test_remove_package() {
        let mut lockfile = create_lockfile();

        let entry = PackageEntry {
            version: "1.0.0".to_string(),
            source: PackageSource::SSC {
                name: "testpkg".to_string(),
            },
            checksum: None,
            group: "production".to_string(),
        };

        add_package(&mut lockfile, "testpkg", entry);
        assert!(has_package(&lockfile, "testpkg"));

        remove_package(&mut lockfile, "testpkg");
        assert!(!has_package(&lockfile, "testpkg"));
    }

    #[test]
    fn test_save_and_load_lockfile() {
        let temp = TempDir::new().unwrap();

        let mut lockfile = create_lockfile();
        add_package(
            &mut lockfile,
            "estout",
            PackageEntry {
                version: "2024.01.15".to_string(),
                source: PackageSource::SSC {
                    name: "estout".to_string(),
                },
                checksum: Some("sha256:abc123".to_string()),
                group: "production".to_string(),
            },
        );

        // Save
        save_lockfile(temp.path(), &lockfile).unwrap();

        // Verify file exists
        assert!(temp.path().join("stacy.lock").exists());

        // Load
        let loaded = load_lockfile(temp.path()).unwrap().unwrap();
        assert_eq!(loaded.version, "1");
        assert_eq!(
            loaded.stacy_version,
            Some(env!("CARGO_PKG_VERSION").to_string())
        );
        assert!(has_package(&loaded, "estout"));

        let entry = get_package(&loaded, "estout").unwrap();
        assert_eq!(entry.version, "2024.01.15");
        assert_eq!(entry.group, "production");
    }

    #[test]
    fn test_save_lockfile_updates_stacy_version() {
        let temp = TempDir::new().unwrap();

        // Create lockfile with different stacy_version
        let mut lockfile = Lockfile {
            version: "1".to_string(),
            stacy_version: Some("0.0.1".to_string()),
            packages: HashMap::new(),
        };
        add_package(
            &mut lockfile,
            "testpkg",
            PackageEntry {
                version: "1.0.0".to_string(),
                source: PackageSource::SSC {
                    name: "testpkg".to_string(),
                },
                checksum: None,
                group: "production".to_string(),
            },
        );

        // Save should update stacy_version to current
        save_lockfile(temp.path(), &lockfile).unwrap();

        // Load and verify version was updated
        let loaded = load_lockfile(temp.path()).unwrap().unwrap();
        assert_eq!(
            loaded.stacy_version,
            Some(env!("CARGO_PKG_VERSION").to_string())
        );
    }

    #[test]
    fn test_load_nonexistent_lockfile() {
        let temp = TempDir::new().unwrap();
        let result = load_lockfile(temp.path()).unwrap();
        assert!(result.is_none());
    }

    #[test]
    fn test_lockfile_header() {
        let temp = TempDir::new().unwrap();
        let lockfile = create_lockfile();

        save_lockfile(temp.path(), &lockfile).unwrap();

        let content = fs::read_to_string(temp.path().join("stacy.lock")).unwrap();
        assert!(content.starts_with("# Auto-generated"));
        assert!(content.contains("do not edit manually"));
    }

    #[test]
    fn test_create_package_entry() {
        let entry = create_package_entry(
            "1.0.0",
            PackageSource::SSC {
                name: "pkg".to_string(),
            },
            "abc123",
            "production",
        );

        assert_eq!(entry.version, "1.0.0");
        assert_eq!(entry.checksum, Some("sha256:abc123".to_string()));
        assert_eq!(entry.group, "production");
    }

    #[test]
    fn test_create_package_entry_dev_group() {
        let entry = create_package_entry(
            "1.0.0",
            PackageSource::SSC {
                name: "pkg".to_string(),
            },
            "abc123",
            "dev",
        );

        assert_eq!(entry.group, "dev");
    }

    #[test]
    fn test_create_package_entry_empty_checksum() {
        let entry = create_package_entry(
            "1.0.0",
            PackageSource::SSC {
                name: "pkg".to_string(),
            },
            "",
            "production",
        );

        assert_eq!(entry.checksum, None);
    }

    #[test]
    fn test_verify_lockfile_sync_in_sync() {
        let mut lockfile = create_lockfile();
        add_package(
            &mut lockfile,
            "estout",
            PackageEntry {
                version: "1.0.0".to_string(),
                source: PackageSource::SSC {
                    name: "estout".to_string(),
                },
                checksum: None,
                group: "production".to_string(),
            },
        );
        add_package(
            &mut lockfile,
            "reghdfe",
            PackageEntry {
                version: "1.0.0".to_string(),
                source: PackageSource::SSC {
                    name: "reghdfe".to_string(),
                },
                checksum: None,
                group: "production".to_string(),
            },
        );

        let config_names = vec!["estout", "reghdfe"];
        let result = verify_lockfile_sync(&lockfile, &config_names);

        assert!(result.in_sync);
        assert!(result.missing_in_lock.is_empty());
        assert!(result.extra_in_lock.is_empty());
    }

    #[test]
    fn test_verify_lockfile_sync_missing_in_lock() {
        let mut lockfile = create_lockfile();
        add_package(
            &mut lockfile,
            "estout",
            PackageEntry {
                version: "1.0.0".to_string(),
                source: PackageSource::SSC {
                    name: "estout".to_string(),
                },
                checksum: None,
                group: "production".to_string(),
            },
        );

        // Config has more packages than lockfile
        let config_names = vec!["estout", "reghdfe", "ftools"];
        let result = verify_lockfile_sync(&lockfile, &config_names);

        assert!(!result.in_sync);
        assert_eq!(result.missing_in_lock, vec!["reghdfe", "ftools"]);
        assert!(result.extra_in_lock.is_empty());
    }

    #[test]
    fn test_verify_lockfile_sync_extra_in_lock() {
        let mut lockfile = create_lockfile();
        add_package(
            &mut lockfile,
            "estout",
            PackageEntry {
                version: "1.0.0".to_string(),
                source: PackageSource::SSC {
                    name: "estout".to_string(),
                },
                checksum: None,
                group: "production".to_string(),
            },
        );
        add_package(
            &mut lockfile,
            "oldpkg",
            PackageEntry {
                version: "1.0.0".to_string(),
                source: PackageSource::SSC {
                    name: "oldpkg".to_string(),
                },
                checksum: None,
                group: "production".to_string(),
            },
        );

        // Config has fewer packages than lockfile
        let config_names = vec!["estout"];
        let result = verify_lockfile_sync(&lockfile, &config_names);

        assert!(!result.in_sync);
        assert!(result.missing_in_lock.is_empty());
        assert_eq!(result.extra_in_lock, vec!["oldpkg"]);
    }

    #[test]
    fn test_verify_lockfile_sync_both_differences() {
        let mut lockfile = create_lockfile();
        add_package(
            &mut lockfile,
            "estout",
            PackageEntry {
                version: "1.0.0".to_string(),
                source: PackageSource::SSC {
                    name: "estout".to_string(),
                },
                checksum: None,
                group: "production".to_string(),
            },
        );
        add_package(
            &mut lockfile,
            "oldpkg",
            PackageEntry {
                version: "1.0.0".to_string(),
                source: PackageSource::SSC {
                    name: "oldpkg".to_string(),
                },
                checksum: None,
                group: "production".to_string(),
            },
        );

        // Config has different packages
        let config_names = vec!["estout", "newpkg"];
        let result = verify_lockfile_sync(&lockfile, &config_names);

        assert!(!result.in_sync);
        assert_eq!(result.missing_in_lock, vec!["newpkg"]);
        assert_eq!(result.extra_in_lock, vec!["oldpkg"]);
    }

    #[test]
    fn test_verify_lockfile_sync_empty() {
        let lockfile = create_lockfile();
        let config_names: Vec<&str> = vec![];
        let result = verify_lockfile_sync(&lockfile, &config_names);

        assert!(result.in_sync);
        assert!(result.missing_in_lock.is_empty());
        assert!(result.extra_in_lock.is_empty());
    }

    #[test]
    fn test_check_version_mismatch_detects_difference() {
        let lockfile = Lockfile {
            version: "1".to_string(),
            stacy_version: Some("0.0.1".to_string()),
            packages: HashMap::new(),
        };

        let result = check_version_mismatch(&lockfile);
        assert!(result.is_some());

        let (lockfile_ver, current_ver) = result.unwrap();
        assert_eq!(lockfile_ver, "0.0.1");
        assert_eq!(current_ver, env!("CARGO_PKG_VERSION"));
    }

    #[test]
    fn test_check_version_mismatch_none_when_same() {
        let lockfile = Lockfile {
            version: "1".to_string(),
            stacy_version: Some(env!("CARGO_PKG_VERSION").to_string()),
            packages: HashMap::new(),
        };

        let result = check_version_mismatch(&lockfile);
        assert!(result.is_none());
    }

    #[test]
    fn test_check_version_mismatch_none_when_missing() {
        // Backwards compatibility: no warning when field is missing
        let lockfile = Lockfile {
            version: "1".to_string(),
            stacy_version: None,
            packages: HashMap::new(),
        };

        let result = check_version_mismatch(&lockfile);
        assert!(result.is_none());
    }

    #[test]
    fn test_load_old_lockfile_without_stacy_version() {
        let temp = TempDir::new().unwrap();

        // Write a lockfile without stacy_version (simulating old format)
        let old_lockfile_content = r#"# Auto-generated by stacy - do not edit manually
# Use `stacy install` to manage packages

version = "1"

[packages]
"#;
        fs::write(temp.path().join("stacy.lock"), old_lockfile_content).unwrap();

        // Should load without error
        let loaded = load_lockfile(temp.path()).unwrap().unwrap();
        assert_eq!(loaded.version, "1");
        assert!(loaded.stacy_version.is_none());
        assert!(loaded.packages.is_empty());
    }

    // M1 regression: Lockfile TOML keys appear in alphabetical order after round-trip
    #[test]
    fn test_lockfile_toml_key_ordering() {
        let temp = TempDir::new().unwrap();

        let mut lockfile = create_lockfile();
        // Add packages in reverse-alpha order
        add_package(
            &mut lockfile,
            "zebra",
            PackageEntry {
                version: "3.0.0".to_string(),
                source: PackageSource::SSC {
                    name: "zebra".to_string(),
                },
                checksum: None,
                group: "production".to_string(),
            },
        );
        add_package(
            &mut lockfile,
            "alpha",
            PackageEntry {
                version: "1.0.0".to_string(),
                source: PackageSource::SSC {
                    name: "alpha".to_string(),
                },
                checksum: None,
                group: "production".to_string(),
            },
        );
        add_package(
            &mut lockfile,
            "middle",
            PackageEntry {
                version: "2.0.0".to_string(),
                source: PackageSource::SSC {
                    name: "middle".to_string(),
                },
                checksum: None,
                group: "production".to_string(),
            },
        );

        // Save and read raw TOML
        save_lockfile(temp.path(), &lockfile).unwrap();
        let raw = fs::read_to_string(temp.path().join("stacy.lock")).unwrap();

        // Find positions of package names in the raw TOML
        let alpha_pos = raw.find("[packages.alpha]").expect("alpha key missing");
        let middle_pos = raw.find("[packages.middle]").expect("middle key missing");
        let zebra_pos = raw.find("[packages.zebra]").expect("zebra key missing");

        assert!(
            alpha_pos < middle_pos && middle_pos < zebra_pos,
            "Lockfile keys should appear alphabetically: alpha({}), middle({}), zebra({})",
            alpha_pos,
            middle_pos,
            zebra_pos
        );
    }
}
